<!--
# This file is automatically generated by the `jsarch`
# module. Do not change it elsewhere, changes would
# be overriden.
-->
# Architecture Notes



## Knifecycle

The `knifecycle` project is intended to be a [dependency
 injection](https://en.wikipedia.org/wiki/Dependency_injection)
 and [inversion of control](https://en.wikipedia.org/wiki/Inversion_of_control)
 tool. It will always be tied to this goal since I prefer
 composing software instead of using frameworks.

It is designed to have a low footprint on services code.
 There is nothing worse than having to write specific code for
 a given tool. With `knifecycle`, services can be either constants,
 functions or objects created synchronously or asynchronously. They
 can be reused elsewhere (even when not using DI) with no changes
 at all.

[See in context](./src/index.js#L34-L48)



### OOP

The `knifecycle` use case is one of the rare use case where
 [OOP](https://en.wikipedia.org/wiki/Object-oriented_programming)
 principles are a good fit.

A service provider is full of state since its concern is
 precisely to
 [encapsulate](https://en.wikipedia.org/wiki/Encapsulation_(computer_programming))
 your application global states.

[See in context](./src/index.js#L50-L59)



### One instance to rule them all

We almost never need to use several Knifecycle instances.
 This is why we are providing the `knifecycle/instance`
 module that give a direct access to a lazy instanciated
 `Knifecycle` instance.

At the same time, I prefer choosing when instantiating a
 singleton this is why I decided to not do it on the behalf
 of the developers by instead providing an opt-in interface
 to this singleton.

[See in context](./src/instance.js#L1-L12)



### Declaring services

The first step to use `knifecycle` is to declare
 services. There are two way of declaring services:
- constants: a constant is a simple value that will
 never change. It can be literal values, objects
 or even functions.
- initializers: they are asynchronous functions
 that handle the initialization phase.

Initializers can be of two types:
- services: a `service` initializer directly
 resolve to the actual service it builds. It can
 be objects, functions or literal values.
- providers: they instead resolve to an object that
 contains the service built into the `service` property
 but also an optional `dispose` property exposing a
 method to properly stop the service and a
 `fatalErrorPromise` that will be rejected if an
 unrecoverable error happens.

 Initializers can be declared as singletons. This means
  that they will be instanciated once for all for each
  executions silos using them (we will cover this
  topic later on).

[See in context](./src/index.js#L129-L154)



#### Dependencies declaration syntax

The dependencies syntax is of the following form:
 `?serviceName>mappedName`
The `?` flag indicates an optionnal dependencies.
 `:mappedName` is optional and says to the container to
 inject `serviceName` but to inject it as `mappedName`.
 It allows to write generic services with fixed
 dependencies and remap their name at injection time.

[See in context](./src/util.js#L278-L287)



### Execution silos

Once all the services are declared, we need a way to bring
 them to life. Execution silos are where the magic happen.
 For each call of the `run` method with given dependencies,
 a new silo is created and the required environment to
 run the actual code is leveraged.

Depending of your application design, you could run it
 in only one execution silo or into several ones
 according to the isolation level your wish to reach.

[See in context](./src/index.js#L467-L477)

