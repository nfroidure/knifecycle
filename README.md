[//]: # ( )
[//]: # (This file is automatically generated by a `metapak`)
[//]: # (module. Do not change it  except between the)
[//]: # (`content:start/end` flags, your changes would)
[//]: # (be overridden.)
[//]: # ( )
# knifecycle
> Manage your NodeJS processes's lifecycle automatically with an unobtrusive dependency injection implementation.

[![GitHub license](https://img.shields.io/badge/license-MIT-blue.svg)](https://github.com/nfroidure/knifecycle/blob/master/LICENSE)
[![Coverage Status](https://coveralls.io/repos/github/nfroidure/knifecycle/badge.svg?branch=master)](https://coveralls.io/github/nfroidure/knifecycle?branch=master)


[//]: # (::contents:start)

[![Browser Support Matrix](https://saucelabs.com/open_sauce/build_matrix/nfroidure.svg)](https://saucelabs.com/u/nfroidure)

Most (maybe all) applications rely on two kinds of dependencies.

**The code dependencies** are fully covered by JavaScript modules in a testable
manner (with `mockery` or `System` directly). There is no need for another
dependency management system if those libraries are pure functions (involve no
global states at all).

Unfortunately, applications often rely on **global states** where the JavaScript
module system shows its limits. This is where `knifecycle` enters the game.

It is largely inspired by the Angular service system except it should not
provide code but access to global states (time, filesystem, db). It also have an
important additional feature to shutdown processes which is really useful for
back-end servers and doesn't exists in Angular.

You may want to look at the [architecture notes](./ARCHITECTURE.md) to better
handle the reasonning behind `knifecycle` and its implementation.

At this point you may think that a DI system is useless. My advice is that it
depends. But at least, you should not make a definitive choice and allow both
approaches. See
[this StackOverflow answer](http://stackoverflow.com/questions/9250851/do-i-need-dependency-injection-in-nodejs-or-how-to-deal-with/44084729#44084729)
for more context about this statement.

## Features

- services management: start services taking their dependencies in count and
  shut them down the same way for graceful exits (namely dependency injection
  with inverted control);
- singleton: maintain singleton services across several running execution silos.
- easy end to end testing: just replace your services per your own mocks and
  stubs while ensuring your application integrity between testing and
  production;
- isolation: isolate processing in a clean manner, per concerns;
- functional programming ready: encapsulate global states allowing the rest of
  your application to be purely functional;
- no circular dependencies for services: while circular dependencies are not a
  problem within purely functional libraries (require allows it), it may be
  harmful for your services, `knifecycle` impeach that while providing an
  `$injector` service Ã  la Angular to allow accessing existing services
  references if you really need to;
- generate Mermaid graphs of the dependency tree;
- build raw initialization modules to avoid embedding Knifecycle in your builds;
- optionally autoload services dependencies with custom logic.

## Usage

Using `knifecycle` is all about declaring the services our application needs and
running your application over it.

Let's say we are building a CLI script. Here is how we would proceed with
Knifecycle:

```js
// bin.js
import fs from 'fs';
import { YError } from 'YError';
import Knifecycle, { initializer, constant, inject, name } from 'knifecycle';

// First of all we create a new Knifecycle instance
const $ = new Knifecycle();

// Some of our code with rely on the process environment
// let's inject it as a constant instead of directly
// pickking env vars in `process.env` to make our code
// easily testable
$.register(constant('ENV', process.env));

// Let's do so for CLI args with another constant
// in real world apps we would have created a service
// that would parse args in a complexer way
$.register(constant('ARGS', process.argv));

// We want our CLI tool to rely on some configuration
// Let's build an injectable service initializer that
// reads environment variables via an injected but
// optional `ENV` object
async function initConfig({ ENV = { CONFIG_PATH: '.' } }) {
  return new Promise((resolve, reject) => {
    fs.readFile(ENV.CONFIG_PATH, 'utf-8', (err, data) => {
      if (err) {
        reject(err);
        return;
      }
      try {
        resolve(JSON.parse(data));
      } catch (err) {
        reject(err);
      }
    });
  });
}

// We are using the `initializer` decorator to
// declare our service initializer specificities
// and register it with our Knifecycle instance
$.register(
  initializer(
    {
      // we have to give our final service a name
      // for further use in other services injections
      name: 'CONFIG',
      // we will need an `ENV` variable in the initializer
      // so adding it in the injected dependencies. The `?`
      // sign tells Knifecycle that the ENV dependency
      // is optional
      inject: ['?ENV'],
      // our initializer is simple so we use the `service`
      // type for the initializer which just indicate that
      // the initializer will return a promise of the actual
      // service
      type: 'service',
      // We don't want to read the config file everytime we
      // inject it so declaring it as a singleton
      singleton: true,
    },
    initConfig,
  ),
);

// Our CLI also uses a database so let's write an
// initializer for it:
const initDB = initializer(
  {
    name: 'db',
    // Here we are injecting the previous `CONFIG` service
    // as required so that our DB cannot be connected without
    // having a proper config.
    inject: ['CONFIG', 'DB_URI', '?log'],
    // The initializer type is slightly different. Indeed,
    // we need to manage the database connection errors
    // and wait for it to flush before shutting down the
    // process.
    // A service provider returns a promise of a provider
    // descriptor exposing:
    // - a mandatory `service` property containing the
    // actual service;
    // - an optional `dispose` function allowing to
    // gracefully close the service;
    // - an optional `fatalErrorPromise` property to
    // handle the service unrecoverable failure.
    type: 'provider',
    singleton: true,
  },
  async ({ CONFIG, DB_URI, log }) => {
    const db = await MongoClient.connect(DB_URI, CONFIG.databaseOptions);
    let fatalErrorPromise = new Promise((resolve, reject) => {
      db.once('error', reject);
    });

    // Logging only if the `log` service is defined
    log && log('info', 'db service initialized!');

    return {
      service: db,
      dispose: db.close.bind(db, true),
      fatalErrorPromise,
    };
  },
);

// Here we are registering our initializer apart to
// be able to reuse it, we also declare the required
// DB_URI constant it needs
$.register(constant('DB_URI', 'posgresql://xxxx'));
$.register(initDB);

// Say we need to use two different DB server
// We can reuse our initializer by tweaking
// some of its properties
$.register(constant('DB_URI2', 'posgresql://yyyy'));
$.register(
  // First we remap the injected dependencies. It will
  // take the `DB_URI2` constant and inject it as
  // `DB_URI`
  inject(
    ['CONFIG', 'DB_URI2>DB_URI', '?log'],
    // Then we override its name to make it
    // available as a different service
    name('db2', initDB),
  ),
);

// A lot of NodeJS functions have some side effects
// declaring them as constants allows you to easily
// mock/monitor/patch it. The `common-services` NPM
// module contains a few useful ones
$.register(constant('now', Date.now.bind(Date)))
  .register(constant('log', console.log.bind(console)))
  .register(constant('exit', process.exit.bind(process)));

// Finally, let's declare an `$autoload` service
// to allow us to load only the initializers needed
// to run the given commands
$.register(
  initializer(
    {
      name: '$autoload',
      type: 'service',
      inject: ['CONFIG', 'ARGS'],
      // Note that the auto loader must be a singleton
      singleton: true,
    },
    async ({ CONFIG, ARGS }) => async (serviceName) => {
      if ('command' !== serviceName) {
        // Allows to signal that the dependency is not found
        // so that optional dependencies doesn't impeach the
        // injector to resolve the dependency tree
        throw new YError('E_UNMATCHED_DEPENDENCY', serviceName);
      }
      try {
        const path = CONFIG.commands + '/' + ARGS[2];
        return {
          path,
          initializer: require(path).default,
        };
      } catch (err) {
        throw new Error(`Cannot load ${serviceName}: ${ARGS[2]}!`);
      }
    },
  ),
);

// At this point, nothing is running. To instanciate the
// services, we have to create an execution silo using
// them. Note that we required the `$instance` service
// implicitly created by `knifecycle`
$.run(['command', '$instance', 'exit', 'log'])
  // Here, command contains the initializer eventually
  // found by automatically loading a NodeJS module
  // in the above `$autoload` service. The db connection
  // will only be instanciated if that command needs it
  .then(async ({ command, $instance, exit, log }) => {
    try {
      command();

      log('It worked!');
    } catch (err) {
      log('It failed!', err);
    } finally {
      // Here we ensure every db connections are closed
      // properly. We could have use `$.destroy()` the same
      // way but this is to illustrate that the Knifecycle
      // instance can be injected in services contexts
      // (rarely done but good to know it exists)
      await $instance.destroy().catch((err) => {
        console.error('Could not exit gracefully:', err);
        exit(1);
      });
    }
  })
  .catch((err) => {
    console.error('Could not launch the app:', err);
    process.exit(1);
  });
```

Running the following should make the magic happen:

```sh
cat "{ commands: './commands'}" > config.json
DEBUG=knifecycle CONFIG_PATH=./config.json node -r @babel/register bin.js mycommand test
// Prints: Could not launch the app: Error: Cannot load command: mycommand!
// (...stack trace)
```

Or at least, we still have to create commands, let's create the `mycommand` one:

```js
// commands/mycommand.js
import { initializer } from './dist';

// A simple command that prints the given args
export default initializer(
  {
    name: 'command',
    type: 'service',
    // Here we could have injected whatever we declared
    // in the previous file: db, now, exit...
    inject: ['ARGS', 'log'],
  },
  async ({ ARGS, log }) => {
    return () => log('Command args:', ARGS.slice(2));
  },
);
```

So now, it works:

```sh
DEBUG=knifecycle CONFIG_PATH=./config.json node -r @babel/register bin.js mycommand test
// Prints: Command args: [ 'mycommand', 'test' ]
// It worked!
```

This is a very simple example but you can find a complexer CLI usage with
`(metapak)[https://github.com/nfroidure/metapak/blob/master/bin/metapak.js]`.

## Auto detection

Knifecycle also provide some utility function to automatically assign the
initializer property declarations, the following 3 ways to declare the `getUser`
service are equivalent:

```js
import noop from 'noop';
import { autoInject, inject, initializer, autoService } from 'knifecycle';

initializer({
  name: 'getUser',
  inject: ['db', '?log'],
  type: 'service',
}, getUser);

service('getUser', autoInject(getUser)));

autoService(getUser);

async function getUser({ db, log = noop}) {}
```

That said, if you need to build your code with `webpack`/`babel` you may have to
convert auto-detections to raw declarations with the
[babel-plugin-knifecycle](https://github.com/nfroidure/babel-plugin-knifecycle)
plugin. You can also do this only for the performance improvements it brings.

Also, keep in mind that the auto-detection is based on a simple regular
expression so you should care to keep initializer signatures simple to avoid
having a `E_AUTO_INJECTION_FAILURE` error. As a rule of thumb, avoid setting
complex default values.

```js
// Won't work
autoInject(async ({ log = () => {} }) => {});

// Will work
function noop() {}
autoInject(async ({ log = noop }) => {});
```

## Debugging

Simply use the DEBUG environment variable by setting it to 'knifecycle':

```sh
DEBUG=knifecycle npm t
```

The output is very verbose but lead to a deep understanding of mechanisms that
take place under the hood.

## Plans

The scope of this library won't change. However the plan is:

- improve performances;
- track bugs ;).

I'll also share most of my own initializers and their stubs/mocks in order to
let you reuse it through your projects easily. Here are the current projects
that use this DI lib:

- [common-services](https://github.com/nfroidure/common-services): contains the
  services I use the most in my apps,
- [memory-kv-store](https://github.com/nfroidure/memory-kv-store): a simple in
  memory key-value store,
- [whook](https://github.com/nfroidure/whook): a framework to build REST web
  services.
- [postgresql-service](https://github.com/nfroidure/postgresql-service): a
  simple wrapper around the `pg` module,
- [jwt-service](https://github.com/nfroidure/jwt-service): a simple wrapper
  around the `jwt` module to simplify its use,
- [ftp-service](https://github.com/nfroidure/ftp-service): a FTP client with
  clean defaults.

Notice that those modules remains usable without using Knifecycle at all which
is maybe the best feature of this library ;).

[//]: # (::contents:end)

# API
## Classes

<dl>
<dt><a href="#Knifecycle">Knifecycle</a></dt>
<dd></dd>
</dl>

## Functions

<dl>
<dt><a href="#initInitializerBuilder">initInitializerBuilder(services)</a> â <code>Promise.&lt;function()&gt;</code></dt>
<dd><p>Instantiate the initializer builder service</p>
</dd>
<dt><a href="#constant">constant(name, value)</a> â <code>function</code></dt>
<dd><p>Decorator that creates an initializer for a constant value</p>
</dd>
<dt><a href="#service">service(serviceBuilder, [name], [dependencies], [singleton], [extra])</a> â <code>function</code></dt>
<dd><p>Decorator that creates an initializer from a service builder</p>
</dd>
<dt><a href="#autoService">autoService(serviceBuilder)</a> â <code>function</code></dt>
<dd><p>Decorator that creates an initializer from a service
 builder by automatically detecting its name
 and dependencies</p>
</dd>
<dt><a href="#provider">provider(providerBuilder, [name], [dependencies], [singleton], [extra])</a> â <code>function</code></dt>
<dd><p>Decorator that creates an initializer for a provider
 builder</p>
</dd>
<dt><a href="#autoProvider">autoProvider(providerBuilder)</a> â <code>function</code></dt>
<dd><p>Decorator that creates an initializer from a provider
 builder by automatically detecting its name
 and dependencies</p>
</dd>
<dt><a href="#handler">handler(handlerFunction, [name], [dependencies], [options])</a> â <code>function</code></dt>
<dd><p>Shortcut to create an initializer with a simple handler</p>
</dd>
<dt><a href="#autoHandler">autoHandler(handlerFunction)</a> â <code>function</code></dt>
<dd><p>Allows to create an initializer with a simple handler automagically</p>
</dd>
<dt><a href="#parseDependencyDeclaration">parseDependencyDeclaration(dependencyDeclaration)</a> â <code>Object</code></dt>
<dd><p>Explode a dependency declaration an returns its parts.</p>
</dd>
<dt><a href="#stringifyDependencyDeclaration">stringifyDependencyDeclaration(dependencyDeclarationParts)</a> â <code>String</code></dt>
<dd><p>Stringify a dependency declaration from its parts.</p>
</dd>
</dl>

<a name="Knifecycle"></a>

## Knifecycle
**Kind**: global class  

* [Knifecycle](#Knifecycle)
    * [new Knifecycle()](#new_Knifecycle_new)
    * [.register(initializer)](#Knifecycle+register) â [<code>Knifecycle</code>](#Knifecycle)
    * [.toMermaidGraph(options)](#Knifecycle+toMermaidGraph) â <code>String</code>
    * [.run(dependenciesDeclarations)](#Knifecycle+run) â <code>Promise</code>
    * [.destroy()](#Knifecycle+destroy) â <code>Promise</code>
    * [._getServiceDescriptor(siloContext, serviceName, options, serviceProvider)](#Knifecycle+_getServiceDescriptor) â <code>Promise</code>
    * [._initializeServiceDescriptor(siloContext, serviceName, options)](#Knifecycle+_initializeServiceDescriptor) â <code>Promise</code>
    * [._initializeDependencies(siloContext, serviceName, servicesDeclarations, options)](#Knifecycle+_initializeDependencies) â <code>Promise</code>

<a name="new_Knifecycle_new"></a>

### new Knifecycle()
Create a new Knifecycle instance

**Returns**: [<code>Knifecycle</code>](#Knifecycle) - The Knifecycle instance  
**Example**  
```js
import Knifecycle from 'knifecycle'

const $ = new Knifecycle();
```
<a name="Knifecycle+register"></a>

### knifecycle.register(initializer) â [<code>Knifecycle</code>](#Knifecycle)
Register an initializer

**Kind**: instance method of [<code>Knifecycle</code>](#Knifecycle)  
**Returns**: [<code>Knifecycle</code>](#Knifecycle) - The Knifecycle instance (for chaining)  

| Param | Type | Description |
| --- | --- | --- |
| initializer | <code>function</code> | An initializer |

<a name="Knifecycle+toMermaidGraph"></a>

### knifecycle.toMermaidGraph(options) â <code>String</code>
Outputs a Mermaid compatible dependency graph of the declared services.
See [Mermaid docs](https://github.com/knsv/mermaid)

**Kind**: instance method of [<code>Knifecycle</code>](#Knifecycle)  
**Returns**: <code>String</code> - Returns a string containing the Mermaid dependency graph  

| Param | Type | Description |
| --- | --- | --- |
| options | <code>Object</code> | Options for generating the graph (destructured) |
| options.shapes | <code>Array.&lt;Object&gt;</code> | Various shapes to apply |
| options.styles | <code>Array.&lt;Object&gt;</code> | Various styles to apply |
| options.classes | <code>Object</code> | A hash of various classes contents |

**Example**  
```js
import Knifecycle, { inject, constant, service } from 'knifecycle';
import appInitializer from './app';

const $ = new Knifecycle();

$.register(constant('ENV', process.env));
$.register(constant('OS', require('os')));
$.register(service('app', inject(['ENV', 'OS'], appInitializer)));
$.toMermaidGraph();

// returns
graph TD
  app-->ENV
  app-->OS
```
<a name="Knifecycle+run"></a>

### knifecycle.run(dependenciesDeclarations) â <code>Promise</code>
Creates a new execution silo

**Kind**: instance method of [<code>Knifecycle</code>](#Knifecycle)  
**Returns**: <code>Promise</code> - Service descriptor promise  

| Param | Type | Description |
| --- | --- | --- |
| dependenciesDeclarations | <code>Array.&lt;String&gt;</code> | Service name. |

**Example**  
```js
import Knifecycle, { constant } from 'knifecycle'

const $ = new Knifecycle();

$.register(constant('ENV', process.env));
$.run(['ENV'])
.then(({ ENV }) => {
 // Here goes your code
})
```
<a name="Knifecycle+destroy"></a>

### knifecycle.destroy() â <code>Promise</code>
Destroy the Knifecycle instance

**Kind**: instance method of [<code>Knifecycle</code>](#Knifecycle)  
**Returns**: <code>Promise</code> - Full destruction promise  
**Example**  
```js
import Knifecycle, { constant } from 'knifecycle'

const $ = new Knifecycle();

$.register(constant('ENV', process.env));
$.run(['ENV'])
.then(({ ENV }) => {
   // Here goes your code

   // Finally destroy the instance
   $.destroy()
})
```
<a name="Knifecycle+_getServiceDescriptor"></a>

### knifecycle.\_getServiceDescriptor(siloContext, serviceName, options, serviceProvider) â <code>Promise</code>
Initialize or return a service descriptor

**Kind**: instance method of [<code>Knifecycle</code>](#Knifecycle)  
**Returns**: <code>Promise</code> - Service descriptor promise.  

| Param | Type | Description |
| --- | --- | --- |
| siloContext | <code>Object</code> | Current execution silo context |
| serviceName | <code>String</code> | Service name. |
| options | <code>Object</code> | Options for service retrieval |
| options.injectorContext | <code>Boolean</code> | Flag indicating the injection were initiated by the $injector |
| options.autoloading | <code>Boolean</code> | Flag to indicating $autoload dependencies on the fly loading |
| serviceProvider | <code>String</code> | Service provider. |

<a name="Knifecycle+_initializeServiceDescriptor"></a>

### knifecycle.\_initializeServiceDescriptor(siloContext, serviceName, options) â <code>Promise</code>
Initialize a service descriptor

**Kind**: instance method of [<code>Knifecycle</code>](#Knifecycle)  
**Returns**: <code>Promise</code> - Service dependencies hash promise.  

| Param | Type | Description |
| --- | --- | --- |
| siloContext | <code>Object</code> | Current execution silo context |
| serviceName | <code>String</code> | Service name. |
| options | <code>Object</code> | Options for service retrieval |
| options.injectorContext | <code>Boolean</code> | Flag indicating the injection were initiated by the $injector |
| options.autoloading | <code>Boolean</code> | Flag to indicating $autoload dependendencies on the fly loading. |

<a name="Knifecycle+_initializeDependencies"></a>

### knifecycle.\_initializeDependencies(siloContext, serviceName, servicesDeclarations, options) â <code>Promise</code>
Initialize a service dependencies

**Kind**: instance method of [<code>Knifecycle</code>](#Knifecycle)  
**Returns**: <code>Promise</code> - Service dependencies hash promise.  

| Param | Type | Description |
| --- | --- | --- |
| siloContext | <code>Object</code> | Current execution silo siloContext |
| serviceName | <code>String</code> | Service name. |
| servicesDeclarations | <code>String</code> | Dependencies declarations. |
| options | <code>Object</code> | Options for service retrieval |
| options.injectorContext | <code>Boolean</code> | Flag indicating the injection were initiated by the $injector |
| options.autoloading | <code>Boolean</code> | Flag to indicating $autoload dependendencies on the fly loading. |

<a name="initInitializerBuilder"></a>

## initInitializerBuilder(services) â <code>Promise.&lt;function()&gt;</code>
Instantiate the initializer builder service

**Kind**: global function  
**Returns**: <code>Promise.&lt;function()&gt;</code> - A promise of the buildInitializer function  

| Param | Type | Description |
| --- | --- | --- |
| services | <code>Object</code> | The services to inject |
| services.$autoload | <code>Object</code> | The dependencies autoloader |

**Example**  
```js
import initInitializerBuilder from 'knifecycle/dist/build';

const buildInitializer = await initInitializerBuilder({
  $autoload: async () => {},
});
```
<a name="initInitializerBuilder..buildInitializer"></a>

### initInitializerBuilder~buildInitializer(dependencies) â <code>Promise.&lt;String&gt;</code>
Create a JavaScript module that initialize
a set of dependencies with hardcoded
import/awaits.

**Kind**: inner method of [<code>initInitializerBuilder</code>](#initInitializerBuilder)  
**Returns**: <code>Promise.&lt;String&gt;</code> - The JavaScript module content  

| Param | Type | Description |
| --- | --- | --- |
| dependencies | <code>Array.&lt;String&gt;</code> | The main dependencies |

**Example**  
```js
import initInitializerBuilder from 'knifecycle/dist/build';

const buildInitializer = await initInitializerBuilder({
  $autoload: async () => {},
});

const content = await buildInitializer(['entryPoint']);
```
<a name="constant"></a>

## constant(name, value) â <code>function</code>
Decorator that creates an initializer for a constant value

**Kind**: global function  
**Returns**: <code>function</code> - Returns a new constant initializer  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>String</code> | The constant's name. |
| value | <code>any</code> | The constant's value |

**Example**  
```js
import Knifecycle, { constant, service } from 'knifecycle';

const { printAnswer } = new Knifecycle()
  .register(constant('THE_NUMBER', value))
  .register(constant('log', console.log.bind(console)))
  .register(service(
    async ({ THE_NUMBER, log }) => () => log(THE_NUMBER),
    'printAnswer',
    ['THE_NUMBER', 'log'],
  ))
  .run(['printAnswer']);

printAnswer(); // 42
```
<a name="service"></a>

## service(serviceBuilder, [name], [dependencies], [singleton], [extra]) â <code>function</code>
Decorator that creates an initializer from a service builder

**Kind**: global function  
**Returns**: <code>function</code> - Returns a new initializer  

| Param | Type | Description |
| --- | --- | --- |
| serviceBuilder | <code>function</code> | An async function to build the service |
| [name] | <code>String</code> | The service's name |
| [dependencies] | <code>Array.&lt;String&gt;</code> | The service's injected dependencies |
| [singleton] | <code>Boolean</code> | Whether the service is a singleton or not |
| [extra] | <code>any</code> | Eventual extra informations |

**Example**  
```js
import Knifecycle, { constant, service } from 'knifecycle';

const { printAnswer } = new Knifecycle()
  .register(constant('THE_NUMBER', value))
  .register(constant('log', console.log.bind(console)))
  .register(service(
    async ({ THE_NUMBER, log }) => () => log(THE_NUMBER),
    'printAnswer',
    ['THE_NUMBER', 'log'],
    true
  ))
  .run(['printAnswer']);

printAnswer(); // 42
```
<a name="autoService"></a>

## autoService(serviceBuilder) â <code>function</code>
Decorator that creates an initializer from a service
 builder by automatically detecting its name
 and dependencies

**Kind**: global function  
**Returns**: <code>function</code> - Returns a new initializer  

| Param | Type | Description |
| --- | --- | --- |
| serviceBuilder | <code>function</code> | An async function to build the service |

<a name="provider"></a>

## provider(providerBuilder, [name], [dependencies], [singleton], [extra]) â <code>function</code>
Decorator that creates an initializer for a provider
 builder

**Kind**: global function  
**Returns**: <code>function</code> - Returns a new provider initializer  

| Param | Type | Description |
| --- | --- | --- |
| providerBuilder | <code>function</code> | An async function to build the service provider |
| [name] | <code>String</code> | The service's name |
| [dependencies] | <code>Array.&lt;String&gt;</code> | The service's dependencies |
| [singleton] | <code>Boolean</code> | Whether the service is a singleton or not |
| [extra] | <code>any</code> | Eventual extra informations |

**Example**  
```js
import Knifecycle, { provider } from 'knifecycle'
import fs from 'fs';

const $ = new Knifecycle();

$.register(provider(configProvider, 'config'));

async function configProvider() {
  return new Promise((resolve, reject) {
    fs.readFile('config.js', function(err, data) {
      let config;

      if(err) {
        reject(err);
        return;
      }

      try {
        config = JSON.parse(data.toString);
      } catch (err) {
        reject(err);
        return;
      }

      resolve({
        service: config,
      });
    });
  });
}
```
<a name="autoProvider"></a>

## autoProvider(providerBuilder) â <code>function</code>
Decorator that creates an initializer from a provider
 builder by automatically detecting its name
 and dependencies

**Kind**: global function  
**Returns**: <code>function</code> - Returns a new provider initializer  

| Param | Type | Description |
| --- | --- | --- |
| providerBuilder | <code>function</code> | An async function to build the service provider |

<a name="handler"></a>

## handler(handlerFunction, [name], [dependencies], [options]) â <code>function</code>
Shortcut to create an initializer with a simple handler

**Kind**: global function  
**Returns**: <code>function</code> - Returns a new initializer  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| handlerFunction | <code>function</code> |  | The handler function |
| [name] | <code>String</code> |  | The name of the handler. Default to the DI prop if exists |
| [dependencies] | <code>Array.&lt;String&gt;</code> | <code>[]</code> | The dependencies to inject in it |
| [options] | <code>Object</code> |  | Options attached to the built initializer |

**Example**  
```js
import Knifecycle, { handler } from 'knifecycle';

new Knifecycle()
.register(handler(getUser, 'getUser', ['db', '?log']));

const QUERY = `SELECT * FROM users WHERE id=$1`
async function getUser({ db }, userId) {
  const [row] = await db.query(QUERY, userId);

  return row;
}
```
<a name="autoHandler"></a>

## autoHandler(handlerFunction) â <code>function</code>
Allows to create an initializer with a simple handler automagically

**Kind**: global function  
**Returns**: <code>function</code> - Returns a new initializer  

| Param | Type | Description |
| --- | --- | --- |
| handlerFunction | <code>function</code> | The handler function |

**Example**  
```js
import Knifecycle, { autoHandler } from 'knifecycle';

new Knifecycle()
.register(autoHandler(getUser));

const QUERY = `SELECT * FROM users WHERE id=$1`
async function getUser({ db }, userId) {
  const [row] = await db.query(QUERY, userId);

  return row;
}
```
<a name="parseDependencyDeclaration"></a>

## parseDependencyDeclaration(dependencyDeclaration) â <code>Object</code>
Explode a dependency declaration an returns its parts.

**Kind**: global function  
**Returns**: <code>Object</code> - The various parts of it  

| Param | Type | Description |
| --- | --- | --- |
| dependencyDeclaration | <code>String</code> | A dependency declaration string |

**Example**  
```js
parseDependencyDeclaration('pgsql>db');
// Returns
{
  serviceName: 'pgsql',
  mappedName: 'db',
  optional: false,
}
```
<a name="stringifyDependencyDeclaration"></a>

## stringifyDependencyDeclaration(dependencyDeclarationParts) â <code>String</code>
Stringify a dependency declaration from its parts.

**Kind**: global function  
**Returns**: <code>String</code> - The various parts of it  

| Param | Type | Description |
| --- | --- | --- |
| dependencyDeclarationParts | <code>Object</code> | A dependency declaration string |

**Example**  
```js
stringifyDependencyDeclaration({
  serviceName: 'pgsql',
  mappedName: 'db',
  optional: false,
});

// Returns
'pgsql>db'
```

# Authors
- [Nicolas Froidure](http://insertafter.com/en/index.html)

# License
[MIT](https://github.com/nfroidure/knifecycle/blob/master/LICENSE)
