[//]: # ( )
[//]: # (This file is automatically generated by a `metapak`)
[//]: # (module. Do not change it  except between the)
[//]: # (`content:start/end` flags, your changes would)
[//]: # (be overridden.)
[//]: # ( )
# knifecycle
> Manage your NodeJS processes's lifecycle automatically with an unobtrusive dependency injection implementation.

[![GitHub license](https://img.shields.io/badge/license-MIT-blue.svg)](https://github.com/nfroidure/knifecycle/blob/master/LICENSE)
[![Build status](https://secure.travis-ci.org/nfroidure/knifecycle.svg)](https://travis-ci.org/nfroidure/knifecycle)
[![Coverage Status](https://coveralls.io/repos/nfroidure/knifecycle/badge.svg?branch=master)](https://coveralls.io/r/nfroidure/knifecycle?branch=master)
[![NPM version](https://badge.fury.io/js/knifecycle.svg)](https://npmjs.org/package/knifecycle)
[![Dependency Status](https://david-dm.org/nfroidure/knifecycle.svg)](https://david-dm.org/nfroidure/knifecycle)
[![devDependency Status](https://david-dm.org/nfroidure/knifecycle/dev-status.svg)](https://david-dm.org/nfroidure/knifecycle#info=devDependencies)
[![Package Quality](http://npm.packagequality.com/shield/knifecycle.svg)](http://packagequality.com/#?package=knifecycle)
[![Code Climate](https://codeclimate.com/github/nfroidure/knifecycle.svg)](https://codeclimate.com/github/nfroidure/knifecycle)


[//]: # (::contents:start)

[![Browser Support Matrix](https://saucelabs.com/open_sauce/build_matrix/nfroidure.svg)](https://saucelabs.com/u/nfroidure)

Most (maybe all) applications rely on two kinds of dependencies.

**The code dependencies** are fully covered by JavaScript
 modules in a testable manner (with `mockery` or `System`
 directly). There is no need for another dependency management
 system if those libraries are pure functions (involve no
 global states at all).

Unfortunately, applications often rely on **global states**
 where the JavaScript module system shows its limits. This
 is where `knifecycle` enters the game.

It is largely inspired by the Angular service system except
 it should not provide code but access to global states
 (time, filesystem, db). It also have an important additional
 feature to shutdown processes which is really useful for
 back-end servers and doesn't exists in Angular.

You may want to look at the
 [architecture notes](./ARCHITECTURE.md) to better handle the
 reasonning behind `knifecycle` and its implementation.

At this point you may think that a DI system is useless. My
 advice is that it depends. But at least, you should not
 make a definitive choice and allow both approaches. See
 [this StackOverflow answer](http://stackoverflow.com/questions/9250851/do-i-need-dependency-injection-in-nodejs-or-how-to-deal-with/44084729#44084729)
 for more context about this statement.

## Features
- services management: start services taking their dependencies
 in count and shut them down the same way for graceful exits
 (namely dependency injection with inverted control);
- singleton: maintain singleton services across several running
 execution silos.
- easy end to end testing: just replace your services per your
 own mocks and stubs while ensuring your application integrity
 between testing and production;
- isolation: isolate processing in a clean manner, per concerns;
- functional programming ready: encapsulate global states
 allowing the rest of your application to be purely functional;
- no circular dependencies for services: while circular
 dependencies are not a problem within purely functional
 libraries (require allows it), it may be harmful for your
 services, `knifecycle` impeach that while providing an
 `$injector` service à la Angular to allow accessing existing
 services references if you really need to;
- generate Mermaid graphs of the dependency tree;
- build raw initialization modules to avoid
 embedding Knifecycle in your builds;
- optionally autoload services dependencies with custom
 logic.

## Usage

Using `knifecycle` is all about declaring the services our
 application needs and running your application over it.

Let's say we are building a CLI script. Here is how we would
 proceed with Knifecycle:
  
First, we need to handle a configuration file so we are
 creating an initializer to instanciate our `CONFIG` service:
```js
// bin.js
import fs from 'fs';
import YError from 'YError';
import Knifecycle, { initializer, constant, inject, name } from 'knifecycle';

// First of all we create a new Knifecycle instance
const $ = new Knifecycle();

// Some of our code with rely on the process environment
// let's inject it as a constant instead of directly
// pickking env vars in `process.env` to make our code
// easily testable
$.register(constant('ENV', process.env));

// Let's do so for CLI args with another constant
// in real world apps we would have created a service
// that would parse args in a complexer way
$.register(constant('ARGS', process.argv));

// We want our CLI tool to rely on some configuration
// Let's build an injectable service initializer that
// reads environment variables via an injected but
// optional `ENV` object
async function initConfig({ ENV = { CONFIG_PATH: '.' } }) {
  return new Promise((resolve, reject) => {
    fs.readFile(ENV.CONFIG_PATH, 'utf-8', (err, data) => {
      if (err) {
        reject(err);
        return;
      }
      try {
        resolve(JSON.parse(data));
      } catch (err) {
        reject(err);
      }
    });
  });
}

// We are using the `initializer` decorator to
// declare our service initializer specificities
// and register it with our Knifecycle instance
$.register(
  initializer(
    {
      // we have to give our final service a name
      // for further use in other services injections
      name: 'CONFIG',
      // we will need an `ENV` variable in the initializer
      // so adding it in the injected dependencies. The `?`
      // sign tells Knifecycle that the ENV dependency
      // is optional
      inject: ['?ENV'],
      // our initializer is simple so we use the `service`
      // type for the initializer which just indicate that
      // the initializer will return a promise of the actual
      // service
      type: 'service',
      // We don't want to read the config file everytime we
      // inject it so declaring it as a singleton
      options: { singleton: true },
    },
    initConfig,
  ),
);

// Our CLI also uses a database so let's write an
// initializer for it:
const initDB = initializer(
  {
    name: 'db',
    // Here we are injecting the previous `CONFIG` service
    // as required so that our DB cannot be connected without
    // having a proper config.
    inject: ['CONFIG', 'DB_URI', '?log'],
    // The initializer type is slightly different. Indeed,
    // we need to manage the database connection errors
    // and wait for it to flush before shutting down the
    // process.
    // A service provider returns a promise of a provider
    // descriptor exposing:
    // - a mandatory `service` property containing the
    // actual service;
    // - an optional `dispose` function allowing to
    // gracefully close the service;
    // - an optional `fatalErrorPromise` property to
    // handle the service unrecoverable failure.
    type: 'provider',
    options: { singleton: true },
  },
  async ({ CONFIG, DB_URI, log }) => {
    const db = await MongoClient.connect(
      DB_URI,
      CONFIG.databaseOptions,
    );
    let fatalErrorPromise = new Promise((resolve, reject) => {
      db.once('error', reject);
    });

    // Logging only if the `log` service is defined
    log && log('info', 'db service initialized!');

    return {
      service: db,
      dispose: db.close.bind(db, true),
      fatalErrorPromise,
    };
  },
);

// Here we are registering our initializer apart to
// be able to reuse it, we also declare the required
// DB_URI constant it needs
$.register(constant('DB_URI', 'posgresql://xxxx'));
$.register(initDB);

// Say we need to use two different DB server
// We can reuse our initializer by tweaking
// some of its properties
$.register(constant('DB_URI2', 'posgresql://yyyy'));
$.register(
  // First we remap the injected dependencies. It will
  // take the `DB_URI2` constant and inject it as
  // `DB_URI`
  inject(
    ['CONFIG', 'DB_URI2>DB_URI', '?log'],
    // Then we override its name to make it
    // available as a different service
    name('db2', initDB),
  ),
);

// A lot of NodeJS functions have some side effects
// declaring them as constants allows you to easily
// mock/monitor/patch it. The `common-services` NPM
// module contains a few useful ones
$.register(constant('now', Date.now.bind(Date)))
  .register(constant('log', console.log.bind(console)))
  .register(constant('exit', process.exit.bind(process)));

// Finally, let's declare an `$autoload` service
// to allow us to load only the initializers needed
// to run the given commands
$.register(
  initializer(
    {
      name: '$autoload',
      type: 'service',
      inject: ['CONFIG', 'ARGS'],
      // Note that the auto loader must be a singleton
      options: { singleton: true }
    },
    async ({ CONFIG, ARGS }) => async serviceName => {
      if ('command' !== serviceName) {
        // Allows to signal that the dependency is not found
        // so that optional dependencies doesn't impeach the
        // injector to resolve the dependency tree
        throw new YError('E_UNMATCHED_DEPENDENCY', serviceName);
      }
      try {
        const path = CONFIG.commands + '/' + ARGS[2];
        return {
          path,
          initializer: require(path).default,
        };
      } catch (err) {
        throw new Error(`Cannot load ${serviceName}: ${ARGS[2]}!`);
      }
    },
  ),
);

// At this point, nothing is running. To instanciate the
// services, we have to create an execution silo using
// them. Note that we required the `$instance` service
// implicitly created by `knifecycle`
$.run(['command', '$instance', 'exit', 'log'])
  // Here, command contains the initializer eventually
  // found by automatically loading a NodeJS module
  // in the above `$autoload` service. The db connection
  // will only be instanciated if that command needs it
  .then(async ({ command, $instance, exit, log }) => {
    try {
      command();

      log('It worked!');
    } catch (err) {
      log('It failed!', err);
    } finally {
      // Here we ensure every db connections are closed
      // properly. We could have use `$.destroy()` the same
      // way but this is to illustrate that the Knifecycle
      // instance can be injected in services contexts
      // (rarely done but good to know it exists)
      await $instance.destroy().catch(err => {
        console.error('Could not exit gracefully:', err);
        exit(1);
      });
    }
  })
  .catch(err => {
    console.error('Could not launch the app:', err);
    process.exit(1);
  });
```
Running the following should make the magic happen:
```sh
cat "{ commands: './commands'}" > config.json
DEBUG=knifecycle CONFIG_PATH=./config.json node -r @babel/register bin.js mycommand test
// Prints: Could not launch the app: Error: Cannot load command: mycommand!
// (...stack trace)
```
Or at least, we still have to create commands, let's create the `mycommand` one:
```js
// commands/mycommand.js
import { initializer } from './dist';

// A simple command that prints the given args
export default initializer(
  {
    name: 'command',
    type: 'service',
    // Here we could have injected whatever we declared
    // in the previous file: db, now, exit...
    inject: ['ARGS', 'log'],
  },
  async ({ ARGS, log }) => {
    return () => log('Command args:', ARGS.slice(2));
  },
);
```
So now, it works:
```sh
DEBUG=knifecycle CONFIG_PATH=./config.json node -r @babel/register bin.js mycommand test
// Prints: Command args: [ 'mycommand', 'test' ]
// It worked!
```

This is a very simple example but you can find a complexer CLI usage
 with `(metapak)[https://github.com/nfroidure/metapak/blob/master/bin/metapak.js]`.

## Auto detection

Knifecycle also provide some utility function to automatically assign
 the initializer property declarations, the following 3 ways to declare
 the `getUser` service are equivalent:
```js
import noop from 'noop';
import { autoInject, inject, initializer, autoService } from 'knifecycle';

initializer({
  name: 'getUser',
  inject: ['db', '?log'],
  type: 'service',
}, getUser);

service('getUser', autoInject(getUser)));

autoService(getUser);

async function getUser({ db, log = noop}) {}
```

That said, if you need to build your code with `webpack`/`babel` you may
 have to convert auto-detections to raw declarations with the
 [babel-plugin-knifecycle](https://github.com/nfroidure/babel-plugin-knifecycle)
 plugin. You can also do this only for the performance improvements it brings.

Also, keep in mind that the auto-detection is based on a simple regular
 expression so you should care to keep initializer signatures simple to
 avoid having a `E_AUTO_INJECTION_FAILURE` error. As a rule of thumb,
 avoid setting complex default values.

```js
// Won't work
autoInject(async ({ log = () => {} }) => {});

// Will work
function noop() {}
autoInject(async ({ log = noop }) => {});
```

## Debugging

Simply use the DEBUG environment variable by setting it to
 'knifecycle':
```sh
DEBUG=knifecycle npm t
```
The output is very verbose but lead to a deep understanding of
 mechanisms that take place under the hood.

## Plans

The scope of this library won't change. However the plan is:
- improve performances;
- evolve with Node: I may not need to transpile this library at
 some point.
- track bugs ;).

I'll also share most of my own initializers and their
 stubs/mocks in order to let you reuse it through
 your projects easily. Here are the current projects
 that use this DI lib:
- [common-services](https://github.com/nfroidure/common-services):
contains the services I use the most in my apps.
- [swagger-http-router](https://github.com/nfroidure/swagger-http-router):
 a complete HTTP router based on OpenAPI definitions with a few useful
 services compatible with Knifecycle.
- [memory-kv-store](https://github.com/nfroidure/memory-kv-store):
 a simple in memory key-value store.
- [whook](https://github.com/nfroidure/whook):
 a framework to build REST web services.
- [postgresql-service](https://github.com/nfroidure/postgresql-service):
 a simple wrapper around the `pg` module.
- [jwt-service](https://github.com/nfroidure/jwt-service):
 a simple wrapper around the `jwt` module to simplify its use.
 
Notice that those modules remains usable without using Knifecycle at
 all which is maybe the best feature of this library ;).

[//]: # (::contents:end)

# API
## Classes

<dl>
<dt><a href="#Knifecycle">Knifecycle</a></dt>
<dd></dd>
</dl>

## Functions

<dl>
<dt><a href="#initInitializerBuilder">initInitializerBuilder(services)</a> ⇒ <code>Promise.&lt;function()&gt;</code></dt>
<dd><p>Instantiate the initializer builder service</p>
</dd>
<dt><a href="#reuseSpecialProps">reuseSpecialProps(from, to, [amend])</a> ⇒ <code>function</code></dt>
<dd><p>Apply special props to the given function from another one</p>
</dd>
<dt><a href="#wrapInitializer">wrapInitializer(wrapper, baseInitializer)</a> ⇒ <code>function</code></dt>
<dd><p>Allows to wrap an initializer to add extra initialization steps</p>
</dd>
<dt><a href="#inject">inject(dependencies, initializer)</a> ⇒ <code>function</code></dt>
<dd><p>Decorator creating a new initializer with different
 dependencies declarations set to it.</p>
</dd>
<dt><a href="#useInject">useInject(from, to)</a> ⇒ <code>function</code></dt>
<dd><p>Apply injected dependencies from the given initializer to another one</p>
</dd>
<dt><a href="#mergeInject">mergeInject(from, to)</a> ⇒ <code>function</code></dt>
<dd><p>Merge injected dependencies of the given initializer with another one</p>
</dd>
<dt><a href="#autoInject">autoInject(initializer)</a> ⇒ <code>function</code></dt>
<dd><p>Decorator creating a new initializer with different
 dependencies declarations set to it according to the
 given function signature.</p>
</dd>
<dt><a href="#alsoInject">alsoInject(dependencies, initializer)</a> ⇒ <code>function</code></dt>
<dd><p>Decorator creating a new initializer with some
 more dependencies declarations appended to it.</p>
</dd>
<dt><a href="#extra">extra(extraInformations, initializer, [merge])</a> ⇒ <code>function</code></dt>
<dd><p>Decorator creating a new initializer with some
 extra informations appended to it. It is just
 a way for user to store some additional
 informations but has no interaction with the
 Knifecycle internals.</p>
</dd>
<dt><a href="#options">options(options, initializer, [merge])</a> ⇒ <code>function</code></dt>
<dd><p>Decorator to amend an initializer options.</p>
</dd>
<dt><a href="#name">name(name, initializer)</a> ⇒ <code>function</code></dt>
<dd><p>Decorator to set an initializer name.</p>
</dd>
<dt><a href="#autoName">autoName(initializer)</a> ⇒ <code>function</code></dt>
<dd><p>Decorator to set an initializer name from its function name.</p>
</dd>
<dt><a href="#type">type(type, initializer)</a> ⇒ <code>function</code></dt>
<dd><p>Decorator to set an initializer type.</p>
</dd>
<dt><a href="#initializer">initializer(properties, initializer)</a> ⇒ <code>function</code></dt>
<dd><p>Decorator to set an initializer properties.</p>
</dd>
<dt><a href="#constant">constant(name, initializer)</a> ⇒ <code>function</code></dt>
<dd><p>Decorator that creates an initializer for a constant value</p>
</dd>
<dt><a href="#service">service(builder, [name], [dependencies], [options])</a> ⇒ <code>function</code></dt>
<dd><p>Decorator that creates an initializer for a service</p>
</dd>
<dt><a href="#autoService">autoService(initializer)</a> ⇒ <code>function</code></dt>
<dd><p>Decorator that auto creates a service</p>
</dd>
<dt><a href="#provider">provider(builder, [name], [dependencies], [options])</a> ⇒ <code>function</code></dt>
<dd><p>Decorator that creates an initializer for a provider</p>
</dd>
<dt><a href="#autoProvider">autoProvider(initializer)</a> ⇒ <code>function</code></dt>
<dd><p>Decorator that auto creates a provider</p>
</dd>
<dt><a href="#handler">handler(handlerFunction, [name], [dependencies], [options])</a> ⇒ <code>function</code></dt>
<dd><p>Shortcut to create an initializer with a simple handler</p>
</dd>
<dt><a href="#autoHandler">autoHandler(handlerFunction)</a> ⇒ <code>function</code></dt>
<dd><p>Allows to create an initializer with a simple handler automagically</p>
</dd>
<dt><a href="#parseDependencyDeclaration">parseDependencyDeclaration(dependencyDeclaration)</a> ⇒ <code>Object</code></dt>
<dd><p>Explode a dependency declaration an returns its parts.</p>
</dd>
<dt><a href="#stringifyDependencyDeclaration">stringifyDependencyDeclaration(dependencyDeclarationParts)</a> ⇒ <code>String</code></dt>
<dd><p>Stringify a dependency declaration from its parts.</p>
</dd>
</dl>

<a name="Knifecycle"></a>

## Knifecycle
**Kind**: global class  

* [Knifecycle](#Knifecycle)
    * [new Knifecycle()](#new_Knifecycle_new)
    * [.register(initializer)](#Knifecycle+register) ⇒ [<code>Knifecycle</code>](#Knifecycle)
    * [.toMermaidGraph(options)](#Knifecycle+toMermaidGraph) ⇒ <code>String</code>
    * [.run(dependenciesDeclarations)](#Knifecycle+run) ⇒ <code>Promise</code>
    * [.destroy()](#Knifecycle+destroy) ⇒ <code>Promise</code>
    * [._getServiceDescriptor(siloContext, serviceName, options, serviceProvider)](#Knifecycle+_getServiceDescriptor) ⇒ <code>Promise</code>
    * [._initializeServiceDescriptor(siloContext, serviceName, options)](#Knifecycle+_initializeServiceDescriptor) ⇒ <code>Promise</code>
    * [._initializeDependencies(siloContext, serviceName, servicesDeclarations, options)](#Knifecycle+_initializeDependencies) ⇒ <code>Promise</code>

<a name="new_Knifecycle_new"></a>

### new Knifecycle()
Create a new Knifecycle instance

**Returns**: [<code>Knifecycle</code>](#Knifecycle) - The Knifecycle instance  
**Example**  
```js
import Knifecycle from 'knifecycle'

const $ = new Knifecycle();
```
<a name="Knifecycle+register"></a>

### knifecycle.register(initializer) ⇒ [<code>Knifecycle</code>](#Knifecycle)
Register an initializer

**Kind**: instance method of [<code>Knifecycle</code>](#Knifecycle)  
**Returns**: [<code>Knifecycle</code>](#Knifecycle) - The Knifecycle instance (for chaining)  

| Param | Type | Description |
| --- | --- | --- |
| initializer | <code>function</code> | An initializer |

<a name="Knifecycle+toMermaidGraph"></a>

### knifecycle.toMermaidGraph(options) ⇒ <code>String</code>
Outputs a Mermaid compatible dependency graph of the declared services.
See [Mermaid docs](https://github.com/knsv/mermaid)

**Kind**: instance method of [<code>Knifecycle</code>](#Knifecycle)  
**Returns**: <code>String</code> - Returns a string containing the Mermaid dependency graph  

| Param | Type | Description |
| --- | --- | --- |
| options | <code>Object</code> | Options for generating the graph (destructured) |
| options.shapes | <code>Array.&lt;Object&gt;</code> | Various shapes to apply |
| options.styles | <code>Array.&lt;Object&gt;</code> | Various styles to apply |
| options.classes | <code>Object</code> | A hash of various classes contents |

**Example**  
```js
import Knifecycle, { inject, constant, service } from 'knifecycle';
import appInitializer from './app';

const $ = new Knifecycle();

$.register(constant('ENV', process.env));
$.register(constant('OS', require('os')));
$.register(service('app', inject(['ENV', 'OS'], appInitializer)));
$.toMermaidGraph();

// returns
graph TD
  app-->ENV
  app-->OS
```
<a name="Knifecycle+run"></a>

### knifecycle.run(dependenciesDeclarations) ⇒ <code>Promise</code>
Creates a new execution silo

**Kind**: instance method of [<code>Knifecycle</code>](#Knifecycle)  
**Returns**: <code>Promise</code> - Service descriptor promise  

| Param | Type | Description |
| --- | --- | --- |
| dependenciesDeclarations | <code>Array.&lt;String&gt;</code> | Service name. |

**Example**  
```js
import Knifecycle, { constant } from 'knifecycle'

const $ = new Knifecycle();

$.register(constant('ENV', process.env));
$.run(['ENV'])
.then(({ ENV }) => {
 // Here goes your code
})
```
<a name="Knifecycle+destroy"></a>

### knifecycle.destroy() ⇒ <code>Promise</code>
Destroy the Knifecycle instance

**Kind**: instance method of [<code>Knifecycle</code>](#Knifecycle)  
**Returns**: <code>Promise</code> - Full destruction promise  
**Example**  
```js
import Knifecycle, { constant } from 'knifecycle'

const $ = new Knifecycle();

$.register(constant('ENV', process.env));
$.run(['ENV'])
.then(({ ENV }) => {
   // Here goes your code

   // Finally destroy the instance
   $.destroy()
})
```
<a name="Knifecycle+_getServiceDescriptor"></a>

### knifecycle.\_getServiceDescriptor(siloContext, serviceName, options, serviceProvider) ⇒ <code>Promise</code>
Initialize or return a service descriptor

**Kind**: instance method of [<code>Knifecycle</code>](#Knifecycle)  
**Returns**: <code>Promise</code> - Service dependencies hash promise.  

| Param | Type | Description |
| --- | --- | --- |
| siloContext | <code>Object</code> | Current execution silo context |
| serviceName | <code>String</code> | Service name. |
| options | <code>Object</code> | Options for service retrieval |
| options.injectorContext | <code>Boolean</code> | Flag indicating the injection were initiated by the $injector |
| options.autoloading | <code>Boolean</code> | Flag to indicating $autoload dependencies on the fly loading |
| serviceProvider | <code>String</code> | Service provider. |

<a name="Knifecycle+_initializeServiceDescriptor"></a>

### knifecycle.\_initializeServiceDescriptor(siloContext, serviceName, options) ⇒ <code>Promise</code>
Initialize a service descriptor

**Kind**: instance method of [<code>Knifecycle</code>](#Knifecycle)  
**Returns**: <code>Promise</code> - Service dependencies hash promise.  

| Param | Type | Description |
| --- | --- | --- |
| siloContext | <code>Object</code> | Current execution silo context |
| serviceName | <code>String</code> | Service name. |
| options | <code>Object</code> | Options for service retrieval |
| options.injectorContext | <code>Boolean</code> | Flag indicating the injection were initiated by the $injector |
| options.autoloading | <code>Boolean</code> | Flag to indicating $autoload dependendencies on the fly loading. |

<a name="Knifecycle+_initializeDependencies"></a>

### knifecycle.\_initializeDependencies(siloContext, serviceName, servicesDeclarations, options) ⇒ <code>Promise</code>
Initialize a service dependencies

**Kind**: instance method of [<code>Knifecycle</code>](#Knifecycle)  
**Returns**: <code>Promise</code> - Service dependencies hash promise.  

| Param | Type | Description |
| --- | --- | --- |
| siloContext | <code>Object</code> | Current execution silo siloContext |
| serviceName | <code>String</code> | Service name. |
| servicesDeclarations | <code>String</code> | Dependencies declarations. |
| options | <code>Object</code> | Options for service retrieval |
| options.injectorContext | <code>Boolean</code> | Flag indicating the injection were initiated by the $injector |
| options.autoloading | <code>Boolean</code> | Flag to indicating $autoload dependendencies on the fly loading. |

<a name="initInitializerBuilder"></a>

## initInitializerBuilder(services) ⇒ <code>Promise.&lt;function()&gt;</code>
Instantiate the initializer builder service

**Kind**: global function  
**Returns**: <code>Promise.&lt;function()&gt;</code> - A promise of the buildInitializer function  

| Param | Type | Description |
| --- | --- | --- |
| services | <code>Object</code> | The services to inject |
| services.$autoload | <code>Object</code> | The dependencies autoloader |

**Example**  
```js
import initInitializerBuilder from 'knifecycle/dist/build';

const buildInitializer = await initInitializerBuilder({
  $autoload: async () => {},
});
```
<a name="initInitializerBuilder..buildInitializer"></a>

### initInitializerBuilder~buildInitializer(dependencies) ⇒ <code>Promise.&lt;String&gt;</code>
Create a JavaScript module that initialize
a set of dependencies with hardcoded
import/awaits.

**Kind**: inner method of [<code>initInitializerBuilder</code>](#initInitializerBuilder)  
**Returns**: <code>Promise.&lt;String&gt;</code> - The JavaScript module content  

| Param | Type | Description |
| --- | --- | --- |
| dependencies | <code>Array.&lt;String&gt;</code> | The main dependencies |

**Example**  
```js
import initInitializerBuilder from 'knifecycle/dist/build';

const buildInitializer = await initInitializerBuilder({
  $autoload: async () => {},
});

const content = await buildInitializer(['entryPoint']);
```
<a name="reuseSpecialProps"></a>

## reuseSpecialProps(from, to, [amend]) ⇒ <code>function</code>
Apply special props to the given function from another one

**Kind**: global function  
**Returns**: <code>function</code> - The newly built function  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| from | <code>function</code> |  | The initialization function in which to pick the props |
| to | <code>function</code> |  | The initialization function from which to build the new one |
| [amend] | <code>Object</code> | <code>{}</code> | Some properties to override |

<a name="wrapInitializer"></a>

## wrapInitializer(wrapper, baseInitializer) ⇒ <code>function</code>
Allows to wrap an initializer to add extra initialization steps

**Kind**: global function  
**Returns**: <code>function</code> - The new initializer  

| Param | Type | Description |
| --- | --- | --- |
| wrapper | <code>function</code> | A function taking dependencies and the base service in arguments |
| baseInitializer | <code>function</code> | The initializer to decorate |

<a name="inject"></a>

## inject(dependencies, initializer) ⇒ <code>function</code>
Decorator creating a new initializer with different
 dependencies declarations set to it.

**Kind**: global function  
**Returns**: <code>function</code> - Returns a new initializer  

| Param | Type | Description |
| --- | --- | --- |
| dependencies | <code>Array.&lt;String&gt;</code> | List of dependencies declarations to declare which  services the initializer needs to resolve its  own service |
| initializer | <code>function</code> | The initializer to tweak |

**Example**  
```js
import Knifecycle, { inject } from 'knifecycle'
import myServiceInitializer from './service';

new Knifecycle()
 .register(
   service(
     inject(['ENV'], myServiceInitializer)
     'myService',
   )
  )
);
```
<a name="useInject"></a>

## useInject(from, to) ⇒ <code>function</code>
Apply injected dependencies from the given initializer to another one

**Kind**: global function  
**Returns**: <code>function</code> - The newly built initialization function  

| Param | Type | Description |
| --- | --- | --- |
| from | <code>function</code> | The initialization function in which to pick the dependencies |
| to | <code>function</code> | The destination initialization function |

<a name="mergeInject"></a>

## mergeInject(from, to) ⇒ <code>function</code>
Merge injected dependencies of the given initializer with another one

**Kind**: global function  
**Returns**: <code>function</code> - The newly built initialization function  

| Param | Type | Description |
| --- | --- | --- |
| from | <code>function</code> | The initialization function in which to pick the dependencies |
| to | <code>function</code> | The destination initialization function |

<a name="autoInject"></a>

## autoInject(initializer) ⇒ <code>function</code>
Decorator creating a new initializer with different
 dependencies declarations set to it according to the
 given function signature.

**Kind**: global function  
**Returns**: <code>function</code> - Returns a new initializer  

| Param | Type | Description |
| --- | --- | --- |
| initializer | <code>function</code> | The original initializer |

**Example**  
```js
import Knifecycle, { autoInject, name } from 'knifecycle'

new Knifecycle()
  .register(
    name(
      'application',
      autoInject(
        async ({ NODE_ENV, mysql: db }) =>
          async () => db.query('SELECT applicationId FROM applications WHERE environment=?', [NODE_ENV])
        )
      )
    )
  )
);
```
<a name="alsoInject"></a>

## alsoInject(dependencies, initializer) ⇒ <code>function</code>
Decorator creating a new initializer with some
 more dependencies declarations appended to it.

**Kind**: global function  
**Returns**: <code>function</code> - Returns a new initializer  

| Param | Type | Description |
| --- | --- | --- |
| dependencies | <code>Array.&lt;String&gt;</code> | List of dependencies declarations to append |
| initializer | <code>function</code> | The initializer to tweak |

**Example**  
```js
import Knifecycle, { alsoInject } from 'knifecycle'
import myServiceInitializer from './service';

new Knifecycle()
.register(service(
  alsoInject(['ENV'], myServiceInitializer),
  'myService',
));
```
<a name="extra"></a>

## extra(extraInformations, initializer, [merge]) ⇒ <code>function</code>
Decorator creating a new initializer with some
 extra informations appended to it. It is just
 a way for user to store some additional
 informations but has no interaction with the
 Knifecycle internals.

**Kind**: global function  
**Returns**: <code>function</code> - Returns a new initializer  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| extraInformations | <code>Object</code> |  | An object containing those extra informations. |
| initializer | <code>function</code> |  | The initializer to tweak |
| [merge] | <code>Boolean</code> | <code>false</code> | Whether the extra object should be merged with the existing one or not |

**Example**  
```js
import Knifecycle, { extra } from 'knifecycle'
import myServiceInitializer from './service';

new Knifecycle()
.register(service(
  extra({ httpHandler: true }, myServiceInitializer),
  'myService',
));
```
<a name="options"></a>

## options(options, initializer, [merge]) ⇒ <code>function</code>
Decorator to amend an initializer options.

**Kind**: global function  
**Returns**: <code>function</code> - Returns a new initializer  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| options | <code>Object</code> |  | Options to set to the initializer |
| options.singleton | <code>Object</code> |  | Define the initializer service as a singleton (one instance for several runs) |
| initializer | <code>function</code> |  | The initializer to tweak |
| [merge] | <code>function</code> | <code>true</code> | Whether options should be merged or not |

**Example**  
```js
import Knifecycle, { inject, options } from 'knifecycle';
import myServiceInitializer from './service';

new Knifecycle()
.register(service(
  inject(['ENV'],
    options({ singleton: true}, myServiceInitializer)
  ),
  'myService',
));
```
<a name="name"></a>

## name(name, initializer) ⇒ <code>function</code>
Decorator to set an initializer name.

**Kind**: global function  
**Returns**: <code>function</code> - Returns a new initializer with that name set  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>String</code> | The name of the service the initializer resolves to. |
| initializer | <code>function</code> | The initializer to tweak |

**Example**  
```js
import Knifecycle, { name } from 'knifecycle';
import myServiceInitializer from './service';

new Knifecycle()
.register(name('myService', myServiceInitializer));
```
<a name="autoName"></a>

## autoName(initializer) ⇒ <code>function</code>
Decorator to set an initializer name from its function name.

**Kind**: global function  
**Returns**: <code>function</code> - Returns a new initializer with that name set  

| Param | Type | Description |
| --- | --- | --- |
| initializer | <code>function</code> | The initializer to name |

**Example**  
```js
import Knifecycle, { autoName } from 'knifecycle';

new Knifecycle()
.register(autoName(async function myService() {}));
```
<a name="type"></a>

## type(type, initializer) ⇒ <code>function</code>
Decorator to set an initializer type.

**Kind**: global function  
**Returns**: <code>function</code> - Returns a new initializer  

| Param | Type | Description |
| --- | --- | --- |
| type | <code>String</code> | The type to set to the initializer. |
| initializer | <code>function</code> | The initializer to tweak |

**Example**  
```js
import Knifecycle, { name, type } from 'knifecycle';
import myServiceInitializer from './service';

new Knifecycle()
.register(
  type('service',
    name('myService',
      myServiceInitializer
    )
  )
);
```
<a name="initializer"></a>

## initializer(properties, initializer) ⇒ <code>function</code>
Decorator to set an initializer properties.

**Kind**: global function  
**Returns**: <code>function</code> - Returns a new initializer  

| Param | Type | Description |
| --- | --- | --- |
| properties | <code>Object</code> | Properties to set to the service. |
| initializer | <code>function</code> | The initializer to tweak |

**Example**  
```js
import Knifecycle, { initializer } from 'knifecycle';
import myServiceInitializer from './service';

new Knifecycle()
.register(initializer({
  name: 'myService',
  type: 'service',
  inject: ['ENV'],
  options: { singleton: true }
}, myServiceInitializer));
```
<a name="constant"></a>

## constant(name, initializer) ⇒ <code>function</code>
Decorator that creates an initializer for a constant value

**Kind**: global function  
**Returns**: <code>function</code> - Returns a new initializer  

| Param | Type | Description |
| --- | --- | --- |
| name | <code>String</code> | The constant's name. |
| initializer | <code>any</code> | The constant's value |

**Example**  
```js
import Knifecycle, { constant, service } from 'knifecycle';

const { printAnswer } = new Knifecycle()
  .register(constant('THE_NUMBER', value))
  .register(constant('log', console.log.bind(console)))
  .register(service(
    async ({ THE_NUMBER, log }) => () => log(THE_NUMBER),
    'printAnswer',
    ['THE_NUMBER', 'log'],
  ))
  .run(['printAnswer']);

printAnswer(); // 42
```
<a name="service"></a>

## service(builder, [name], [dependencies], [options]) ⇒ <code>function</code>
Decorator that creates an initializer for a service

**Kind**: global function  
**Returns**: <code>function</code> - Returns a new initializer  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>function</code> | An initializer returning the service promise |
| [name] | <code>String</code> | The service's name |
| [dependencies] | <code>Array.&lt;String&gt;</code> | The service's dependencies |
| [options] | <code>Object</code> | Options attached to the built initializer |

**Example**  
```js
import Knifecycle, { constant, service } from 'knifecycle';

const { printAnswer } = new Knifecycle()
  .register(constant('THE_NUMBER', value))
  .register(constant('log', console.log.bind(console)))
  .register(service(
    async ({ THE_NUMBER, log }) => () => log(THE_NUMBER),
    'printAnswer',
    ['THE_NUMBER', 'log'],
    { singleton: true }
  ))
  .run(['printAnswer']);

printAnswer(); // 42
```
<a name="autoService"></a>

## autoService(initializer) ⇒ <code>function</code>
Decorator that auto creates a service

**Kind**: global function  
**Returns**: <code>function</code> - Returns a new initializer  

| Param | Type | Description |
| --- | --- | --- |
| initializer | <code>function</code> | An initializer returning the service promise |

<a name="provider"></a>

## provider(builder, [name], [dependencies], [options]) ⇒ <code>function</code>
Decorator that creates an initializer for a provider

**Kind**: global function  
**Returns**: <code>function</code> - Returns a new initializer  

| Param | Type | Description |
| --- | --- | --- |
| builder | <code>function</code> | A builder returning the provider promise |
| [name] | <code>String</code> | The service's name |
| [dependencies] | <code>Array.&lt;String&gt;</code> | The service's dependencies |
| [options] | <code>Object</code> | Options attached to the built initializer |

**Example**  
```js
import Knifecycle, { provider } from 'knifecycle'
import fs from 'fs';

const $ = new Knifecycle();

$.register(provider(configProvider, 'config'));

async function configProvider() {
  return new Promise((resolve, reject) {
    fs.readFile('config.js', function(err, data) {
      let config;

      if(err) {
        reject(err);
        return;
      }

      try {
        config = JSON.parse(data.toString);
      } catch (err) {
        reject(err);
        return;
      }

      resolve({
        service: config,
      });
    });
  });
}
```
<a name="autoProvider"></a>

## autoProvider(initializer) ⇒ <code>function</code>
Decorator that auto creates a provider

**Kind**: global function  
**Returns**: <code>function</code> - Returns a new initializer  

| Param | Type | Description |
| --- | --- | --- |
| initializer | <code>function</code> | An initializer returning the provider promise |

<a name="handler"></a>

## handler(handlerFunction, [name], [dependencies], [options]) ⇒ <code>function</code>
Shortcut to create an initializer with a simple handler

**Kind**: global function  
**Returns**: <code>function</code> - Returns a new initializer  

| Param | Type | Default | Description |
| --- | --- | --- | --- |
| handlerFunction | <code>function</code> |  | The handler function |
| [name] | <code>String</code> |  | The name of the handler. Default to the DI prop if exists |
| [dependencies] | <code>Array.&lt;String&gt;</code> | <code>[]</code> | The dependencies to inject in it |
| [options] | <code>Object</code> |  | Options attached to the built initializer |

**Example**  
```js
import Knifecycle, { handler } from 'knifecycle';

new Knifecycle()
.register(handler(getUser, 'getUser', ['db', '?log']));

const QUERY = `SELECT * FROM users WHERE id=$1`
async function getUser({ db }, userId) {
  const [row] = await db.query(QUERY, userId);

  return row;
}
```
<a name="autoHandler"></a>

## autoHandler(handlerFunction) ⇒ <code>function</code>
Allows to create an initializer with a simple handler automagically

**Kind**: global function  
**Returns**: <code>function</code> - Returns a new initializer  

| Param | Type | Description |
| --- | --- | --- |
| handlerFunction | <code>function</code> | The handler function |

**Example**  
```js
import Knifecycle, { autoHandler } from 'knifecycle';

new Knifecycle()
.register(autoHandler(getUser));

const QUERY = `SELECT * FROM users WHERE id=$1`
async function getUser({ db }, userId) {
  const [row] = await db.query(QUERY, userId);

  return row;
}
```
<a name="parseDependencyDeclaration"></a>

## parseDependencyDeclaration(dependencyDeclaration) ⇒ <code>Object</code>
Explode a dependency declaration an returns its parts.

**Kind**: global function  
**Returns**: <code>Object</code> - The various parts of it  

| Param | Type | Description |
| --- | --- | --- |
| dependencyDeclaration | <code>String</code> | A dependency declaration string |

**Example**  
```js
parseDependencyDeclaration('pgsql>db');
// Returns
{
  serviceName: 'pgsql',
  mappedName: 'db',
  optional: false,
}
```
<a name="stringifyDependencyDeclaration"></a>

## stringifyDependencyDeclaration(dependencyDeclarationParts) ⇒ <code>String</code>
Stringify a dependency declaration from its parts.

**Kind**: global function  
**Returns**: <code>String</code> - The various parts of it  

| Param | Type | Description |
| --- | --- | --- |
| dependencyDeclarationParts | <code>Object</code> | A dependency declaration string |

**Example**  
```js
stringifyDependencyDeclaration({
  serviceName: 'pgsql',
  mappedName: 'db',
  optional: false,
});

// Returns
'pgsql>db'
```

# Authors
- [Nicolas Froidure](http://insertafter.com/en/index.html)

# License
[MIT](https://github.com/nfroidure/knifecycle/blob/master/LICENSE)
